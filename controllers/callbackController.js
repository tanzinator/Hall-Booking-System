
const Razorpay = require('razorpay');
const fs = require('fs');

const nodemailer = require('nodemailer');
const { createInvoice } = require('./pdfinvoice');
const crypto = require('crypto');


const db = require('../utils/db_config');

exports.eventListener = (req, res, next) => {
  console.log('webhook activated');
  const mySecret = "4567890";

  let reqBody = "";
  let signature = req.headers["x-razorpay-signature"];
  const shasum = crypto.createHmac('sha256', mySecret)
  shasum.update(JSON.stringify(req.body))
  const digest = shasum.digest('hex');

  // console.log(digest,req.headers["x-razorpay-signature"])

  // req.on("data", (data) => {

  //   reqBody += data;
  // });

  // req.on("end", (data) => {

  console.log("is signature valid");
  //Check for payment.failed, invoice.paid, invoice.expired
  if (digest === req.headers["x-razorpay-signature"]) {
    // console.log(req.body.payload);
    var obj = req.body.payload;
    // console.log(obj);
    //this is the format of the webhook
    //console.log(reqBody);
    //Checking if payment was successful

    if (obj.payment.entity.status === 'captured') {
      console.log(`Processing for Invoice ID ${obj.payment.entity.invoice_id}`);
      var sql = "SELECT * FROM payments WHERE paymentid= '" + obj.payment.entity.invoice_id + "'"
      db.qb.query(sql, (err, response) => {
        if (err) {
          console.log('some error fetching invoice from table')
          return res.sendStatus(200);
        }
        if (!response || !response[0] || response[0].status == 'Invoice Issued') {
          console.log('either invoice doesnt exist or already paid')
          return res.sendStatus(200);
        }
        if (response[0].status == 'Payment Requested' && parseInt(response[0].totalamount) === parseInt(obj.payment.entity.amount) / 100) {
          var sql2 = "SELECT * FROM venue_bookings WHERE booking_id='" + response[0].bookingid + "'"
          db.qb.query(sql2, (err, result) => {
            if (err) {
              return res.sendStatus(200);
            }

            {
              var customerGST;
              if (typeof (result[0].gstin) === 'undefined' || result[0].gstin.length !== 15) {
                customerGST = '';
              }
              else {
                customerGST = result[0].gstin;
              }

              const invoiceStruct = {
                shipping: {
                  name: result[0].first_name + ' ' + result[0].last_name
                  // address: obj.payload.invoice.entity.customer_details.billing_address,
                  // city: "Panaji",
                  // state: "Goa",
                  // country: "India",
                  // postal_code: 403002
                },
                items: [
                  {
                    item: "Hall Booking Charges",
                    description: "Hall Booking Charges",
                    quantity: 1,
                    amount: parseInt(obj.payment.entity.amount) / 1.18
                  }
                ],
                subtotal: parseInt(obj.payment.entity.amount) / 1.18,
                CGST: 0.09 * parseInt(obj.payment.entity.amount) / 1.18,
                SGST: 0.09 * parseInt(obj.payment.entity.amount) / 1.18,
                paid: parseInt(obj.payment.entity.amount),
                invoice_nr: obj.payment.entity.invoice_id,
                bookingId: response[0].bookingid,
                customerGST: customerGST

              };



              setTimeout(createInvoice, 3000, invoiceStruct, obj.payment.entity.invoice_id + '.pdf');
              //PDF Invoice Gen End

              //Invoice Mail Send Start
              setTimeout(delayedNodeMailer, 3000, result, obj, res);
              function delayedNodeMailer(result, obj, res) {
                //console.log('response0', result[0], 'obj', obj, 'res', res);
                var transporter = nodemailer.createTransport({
                  service: 'gmail',
                  auth: {
                    user: 'marutimandirdavorlim@gmail.com',
                    pass: 'crwtvizsvgvblhom'
                  }
                });

                var mailOptions = {
                  from: 'marutimandirdavorlim@gmail.com',
                  to: result[0].email,
                  subject: 'Maruti Mandir Hall Booking Invoice',
                  text: `Dear Sir/Madam,\nPlease find attached the invoice towards Hall Booking Charges.\n\n\nAUTOGENERATED EMAIL`,
                  attachments: {
                    path: obj.payment.entity.invoice_id + '.pdf'
                  }
                };

                transporter.sendMail(mailOptions, function (error, info) {
                  if (error) {
                    console.log(error);
                    return res.sendStatus(200);
                  } else {

                    console.log('Email sent: ' + info.response);
                    //const invoiceStatus = 'Invoice Issued'
                    const newInvoiceId = obj.payment.entity.invoice_id;
                    var payAmount = parseInt(obj.payment.entity.amount) / 100
                    var paidAt = new Date().getTime() - 5.5 * 3600 * 1000;
                    var tax = 0.18 * (payAmount / 1.18);
                    sql = "UPDATE payments SET status='Invoice Issued', amountpaid=" + payAmount + ",paidat=" + paidAt + " WHERE paymentid='" + newInvoiceId + "'"
                    // sql='UPDATE payments SET status=? AND amountpaid=? WHERE paymentid=?',[invoiceStatus,parseInt(obj.payment.entity.amount)/100,obj.payment.entity.invoice_id]
                    // sql=`UPDATE payments SET status=${invoiceStatus} AND amountpaid=${parseInt(obj.payment.entity.amount)/100} WHERE paymentid=${obj.payment.entity.invoice_id}`
                    db.qb.query(sql, (err, resp) => {
                      if (err) {
                        console.log('Unable to update invocice status', obj.payment.entity.invoice_id + err);
                        res.sendStatus(200);
                      }
                      if (!err) {
                        console.log('Invoice Status Updated');

                        fs.unlink('./' + obj.payment.entity.invoice_id + '.pdf', (err) => {
                          if (err) {
                            console.log('File Delete Error', err);
                            return;
                          }
                          else {

                            var getBookingId = "select * from payments where paymentid='" + newInvoiceId + "'"
                            db.qb.query(getBookingId, function (err, payRes) {
                              if (err) {
                                console.log('get booking id error', err);
                                return;
                              }
                              else {
                                var bookId = payRes[0]['bookingid']
                                var updateApprovalStatus = "update venue_bookings set booking_status='Paid' where booking_id=" + parseInt(bookId)
                                db.qb.query(updateApprovalStatus, function (err, venBookUpdate) {
                                  if (err) {
                                    console.log('update booking status error', err);
                                    return;
                                  }
                                  else {
                                    res.sendStatus(200);
                                  }
                                })
                              }

                            })

                          }
                        });


                      }

                    });
                  }
                });
              }
            }
          })

        }
        else {
          console.log('amount incorrect paid')
          res.sendStatus(200);
        }
      });
      //if invoice code does not exist in invoice table and status is not paid then proceed



      //PDF Invoice Gen Start

    }



    //Code for failed payment webhook
    else if (obj.payment.entity.status === 'payment.failed') {

      return res.sendStatus(200);



    }
    else {
      console.log('Some other Status');
      return res.sendStatus(200);
    }





  }
  else {
    console.log('Incorrect Secret');
    return res.sendStatus(200);

  }
  // });



};